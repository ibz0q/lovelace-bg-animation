version: v1
metadata:
  name: Icelandic Aurora v2
  description: Watch the aurora borealis dance across your screen. (Improved performance)
  author: Ibz
  source: https://github.com/ibz0q/lovelace-bg-animation
  tags:
    - interactive
parameters:
  - name: speed
    default: 0.5
    description: Animation movement speed
    type: number
    helper: number(0.1-2)
    behavior: environment
  - name: blurIntensity
    default: 60
    description: Intensity of the blur effect (10-100)
    type: number
    behavior: environment
  - name: colorIntensity
    default: 0.7
    description: Intensity of colors (0.3-1.0)
    type: number
    behavior: environment
  - name: targetFPS
    default: 60
    description: Target frames per second
    type: number
    behavior: environment
    helper: number(10-100)
  - name: controlsVisible
    default: false
    description: Show controls by default
    type: boolean
    behavior: environment

helpers:
  insert_baseurl: true
template: >
  <!DOCTYPE html>
  <html lang="en">
    <head>
      <meta charset="UTF-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <title>WebGL Aurora Borealis</title>
      <style>
        * {
          margin: 0;
          padding: 0;
          box-sizing: border-box;
        }

        body, html {
          height: 100%;
          overflow: hidden;
          background: #000;
        }

        canvas {
          display: block;
          width: 100vw;
          height: 100vh;
        }

        .ui-container {
          transition: opacity 0.5s ease, visibility 0.5s ease;
          opacity: 0;
          visibility: hidden;
          pointer-events: none;
        }

        .ui-container.visible {
          opacity: 1;
          visibility: visible;
          pointer-events: auto;
        }

        .controls {
          position: fixed;
          top: 20px;
          right: 20px;
          z-index: 100;
          background: rgba(255, 255, 255, 0.1);
          backdrop-filter: blur(10px);
          border-radius: 12px;
          padding: 20px;
          color: white;
          font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
          font-size: 14px;
          border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .toggle-button {
          position: fixed;
          top: 20px;
          right: 20px;
          z-index: 101;
          background: rgba(255, 255, 255, 0.15);
          backdrop-filter: blur(10px);
          border: 1px solid rgba(255, 255, 255, 0.3);
          color: white;
          width: 44px;
          height: 44px;
          border-radius: 22px;
          cursor: pointer;
          font-size: 18px;
          display: flex;
          align-items: center;
          justify-content: center;
          transition: all 0.3s ease;
          font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        .toggle-button:hover {
          background: rgba(255, 255, 255, 0.25);
          transform: scale(1.05);
        }

        .toggle-button.controls-visible {
          transform: translateX(-280px);
        }

        .control-group {
          margin-bottom: 15px;
        }

        .control-group:last-child {
          margin-bottom: 0;
        }

        label {
          display: block;
          margin-bottom: 5px;
          font-weight: 500;
        }

        input[type="range"] {
          width: 100%;
          margin-bottom: 5px;
        }

        button {
          background: rgba(255, 255, 255, 0.2);
          border: 1px solid rgba(255, 255, 255, 0.3);
          color: white;
          padding: 8px 16px;
          border-radius: 6px;
          cursor: pointer;
          font-size: 12px;
          margin-right: 8px;
          margin-bottom: 8px;
        }

        button:hover {
          background: rgba(255, 255, 255, 0.3);
        }

        .keyboard-hint {
          position: fixed;
          bottom: 20px;
          left: 20px;
          z-index: 100;
          background: rgba(255, 255, 255, 0.1);
          backdrop-filter: blur(10px);
          border-radius: 8px;
          padding: 12px 16px;
          color: white;
          font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
          font-size: 12px;
          border: 1px solid rgba(255, 255, 255, 0.2);
          opacity: 0.7;
          transition: opacity 0.3s ease;
        }

        .keyboard-hint:hover {
          opacity: 1;
        }
      </style>
    </head>
    <body>
      <canvas id="auroraCanvas"></canvas>

      <div class="ui-container" id="uiContainer">
        <button class="toggle-button controls-visible" id="toggleButton" title="Hide Controls (H)">
          ⚙️
        </button>

        <div class="controls" id="controlPanel">
          <div class="control-group">
            <label>Animation Speed</label>
            <input type="range" id="speedControl" min="0.1" max="2" step="0.1" value="0.5" />
          </div>

          <div class="control-group">
            <label>Blur Intensity</label>
            <input type="range" id="blurControl" min="10" max="100" step="5" value="40" />
          </div>

          <div class="control-group">
            <label>Color Intensity</label>
            <input type="range" id="intensityControl" min="0.3" max="1" step="0.1" value="0.7" />
          </div>

          <div class="control-group">
            <button onclick="randomizeColors()">Randomize Colors</button>
            <button onclick="saveImage()">Save Image</button>
          </div>
        </div>
      </div>

      <script>
        class WebGLAurora {
          constructor() {
            this.canvas = document.getElementById("auroraCanvas");
            // For now, use Canvas 2D for reliability
            this.useWebGL = false;
            this.fallbackToCanvas2D();

            this.animationId = null;
            this.time = 0;

                         // Animation settings
             this.speed = window.env?.speed ?? 0.2;
             this.blurIntensity = window.env?.blurIntensity ?? 40;
             this.colorIntensity = window.env?.colorIntensity ?? 0.7;

             // Performance optimization
             this.lastFrameTime = 0;
             this.targetFPS = window.env?.targetFPS ?? 60;
             this.frameInterval = 1000 / this.targetFPS;

             // Animation state
             this.isAnimating = true;

            // UI state
            this.controlsVisible = window.env?.controlsVisible ?? false;

            // Generate random aurora streaks
            this.auroraStreaks = this.generateRandomStreaks();

            this.init();
            this.setupEventListeners();
            this.setupControlToggle();
            this.initializeUIState();
            this.animate();
          }

                    generateRandomStreaks() {
            const baseColors = [
              [138, 43, 226], // Purple
              [75, 0, 130],   // Indigo
              [0, 191, 255],  // Deep Sky Blue
              [72, 61, 139],  // Dark Slate Blue
              [123, 104, 238], // Medium Slate Blue
              [0, 206, 209],  // Dark Turquoise
              [147, 0, 211],  // Dark Violet
              [30, 144, 255], // Dodger Blue
              [106, 90, 205], // Slate Blue
              [0, 255, 255],  // Cyan
            ];

            const streaks = [];
            const numStreaks = 6 + Math.floor(Math.random() * 3);

            for (let i = 0; i < numStreaks; i++) {
              streaks.push({
                x: Math.random(),
                y: Math.random(),
                angle: Math.random() * 360,
                length: 2.0 + Math.random() * 2.0,
                width: 0.8 + Math.random() * 1.5,
                color: baseColors[Math.floor(Math.random() * baseColors.length)],
                speed: 0.5 + Math.random() * 1.0,
                angleSpeed: 0.2 + Math.random() * 0.4,
              });
            }

            return streaks;
          }

          init() {
            this.resizeCanvas();
            window.addEventListener("resize", () => this.resizeCanvas());
          }

          resizeCanvas() {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
          }

          setupEventListeners() {
            document.getElementById("speedControl").addEventListener("input", (e) => {
              this.speed = parseFloat(e.target.value);
            });

            document.getElementById("blurControl").addEventListener("input", (e) => {
              this.blurIntensity = parseInt(e.target.value);
            });

            document.getElementById("intensityControl").addEventListener("input", (e) => {
              this.colorIntensity = parseFloat(e.target.value);
            });

            this.canvas.addEventListener("click", (e) => {
              this.regenerateAurora();
            });
          }

          setupControlToggle() {
            const toggleButton = document.getElementById("toggleButton");
            const uiContainer = document.getElementById("uiContainer");

            toggleButton.addEventListener("click", () => {
              this.toggleControls();
            });

            document.addEventListener("keydown", (e) => {
              if (e.key.toLowerCase() === "h" && !e.ctrlKey && !e.metaKey && !e.altKey) {
                e.preventDefault();
                this.toggleControls();
              }
            });
          }

          toggleControls() {
            const uiContainer = document.getElementById("uiContainer");
            this.controlsVisible = !this.controlsVisible;

            if (this.controlsVisible) {
              uiContainer.classList.add("visible");
            } else {
              uiContainer.classList.remove("visible");
            }
          }

          render(currentTime) {
            this.renderCanvas2D(currentTime);
          }

          renderCanvas2D(currentTime) {
            const { width, height } = this.canvas;

            // Clear canvas efficiently
            this.ctx.clearRect(0, 0, width, height);
            this.ctx.fillStyle = "#000000";
            this.ctx.fillRect(0, 0, width, height);

            // Set blend mode and filter once
            this.ctx.globalCompositeOperation = "screen";
            this.ctx.filter = `blur(${this.blurIntensity}px)`;

            const timeSpeed = this.time * this.speed;

            // Draw each aurora streak
            for (let i = 0; i < this.auroraStreaks.length; i++) {
              this.drawCanvas2DStreak(this.auroraStreaks[i], timeSpeed);
            }

            // Reset context state once
            this.ctx.filter = "none";
            this.ctx.globalCompositeOperation = "source-over";
          }

                     

          drawCanvas2DStreak(streak, timeSpeed) {
            const { width, height } = this.canvas;
            const minDimension = Math.min(width, height);

            // Calculate position with animation
            const baseX = streak.x * width;
            const baseY = streak.y * height;
            const offsetX = Math.sin(timeSpeed * streak.speed * 0.001) * width * 0.2;
            const offsetY = Math.cos(timeSpeed * streak.speed * 0.001 * 0.8) * height * 0.2;
            const centerX = baseX + offsetX;
            const centerY = baseY + offsetY;

            // Calculate rotation
            const currentAngle = streak.angle + Math.sin(timeSpeed * streak.angleSpeed * 0.001) * 45;
            const angleRad = currentAngle * Math.PI / 180;

            // Calculate dimensions
            const length = streak.length * minDimension * 0.8;
            const streakWidth = streak.width * minDimension * 0.3;

            // Create gradient
            const cosAngle = Math.cos(angleRad);
            const sinAngle = Math.sin(angleRad);
            const halfLength = length * 0.5;

            const startX = centerX - cosAngle * halfLength;
            const startY = centerY - sinAngle * halfLength;
            const endX = centerX + cosAngle * halfLength;
            const endY = centerY + sinAngle * halfLength;

            const gradient = this.ctx.createLinearGradient(startX, startY, endX, endY);
            const [r, g, b] = streak.color;
            const intensity = this.colorIntensity;

            gradient.addColorStop(0, `rgba(${Math.floor(r * intensity * 0.1)}, ${Math.floor(g * intensity * 0.1)}, ${Math.floor(b * intensity * 0.1)}, 0)`);
            gradient.addColorStop(0.3, `rgba(${Math.floor(r * intensity * 0.7)}, ${Math.floor(g * intensity * 0.7)}, ${Math.floor(b * intensity * 0.7)}, 0.4)`);
            gradient.addColorStop(0.5, `rgba(${Math.floor(r * intensity)}, ${Math.floor(g * intensity)}, ${Math.floor(b * intensity)}, 0.9)`);
            gradient.addColorStop(0.7, `rgba(${Math.floor(r * intensity * 0.7)}, ${Math.floor(g * intensity * 0.7)}, ${Math.floor(b * intensity * 0.7)}, 0.4)`);
            gradient.addColorStop(1, `rgba(${Math.floor(r * intensity * 0.1)}, ${Math.floor(g * intensity * 0.1)}, ${Math.floor(b * intensity * 0.1)}, 0)`);

            // Draw the streak
            this.ctx.save();
            this.ctx.translate(centerX, centerY);
            this.ctx.rotate(angleRad);

            this.ctx.beginPath();
            this.ctx.ellipse(0, 0, length * 0.6, streakWidth, 0, 0, Math.PI * 2);
            this.ctx.fillStyle = gradient;
            this.ctx.fill();

            this.ctx.restore();
          }

                     animate(currentTime = 0) {
             if (currentTime - this.lastFrameTime >= this.frameInterval) {
               this.time += this.speed * 16;
               this.render(currentTime);
               this.lastFrameTime = currentTime;
             }

             this.animationId = requestAnimationFrame((time) => this.animate(time));
           }

                     regenerateAurora() {
             this.auroraStreaks = this.generateRandomStreaks();
             this.time = 0;

             if (!this.animationId) {
               this.animate();
             }
           }

          randomizeColors() {
            this.regenerateAurora();
          }

          saveImage() {
            const link = document.createElement("a");
            link.download = `aurora-background-${Date.now()}.png`;
            link.href = this.canvas.toDataURL();
            link.click();
          }

                     restartAnimation() {
             this.time = 0;
             if (!this.animationId) {
               this.animate();
             }
             console.log("Animation restarted");
           }

           stopAnimation() {
             if (this.animationId) {
               cancelAnimationFrame(this.animationId);
               this.animationId = null;
             }
             console.log("Animation stopped manually");
           }

          fallbackToCanvas2D() {
            console.log("Using Canvas 2D fallback");
            this.ctx = this.canvas.getContext("2d");
            this.useWebGL = false;
            
            // Optimize canvas context
            this.ctx.imageSmoothingEnabled = true;
            this.ctx.imageSmoothingQuality = "high";
          }

          initializeUIState() {
            const uiContainer = document.getElementById("uiContainer");
            if (this.controlsVisible) {
              uiContainer.classList.add("visible");
            }
          }
        }

        // Global functions for button controls
        function randomizeColors() {
          if (window.auroraGenerator) {
            window.auroraGenerator.randomizeColors();
          }
        }

        function saveImage() {
          if (window.auroraGenerator) {
            window.auroraGenerator.saveImage();
          }
        }

        // Initialize the WebGL aurora generator when the page loads
        window.addEventListener("DOMContentLoaded", () => {
          window.auroraGenerator = new WebGLAurora();

          if (window.auroraGenerator.controlsVisible) {
            const uiContainer = document.getElementById("uiContainer");
            if (uiContainer) {
              uiContainer.classList.add("visible");
            }
          }
        });
      </script>
    </body>
  </html>
